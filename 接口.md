# 后端接口及相应数据库设计

## 当前已有数据库表结构

```dataset
CREATE TABLE user (
	id INTEGER NOT NULL, 
	email VARCHAR(255) NOT NULL, 
	full_name VARCHAR(100) NOT NULL, 
	phone VARCHAR(20), 
	campus VARCHAR(100), 
	avatar_url VARCHAR(255), 
	hashed_password VARCHAR(255) NOT NULL, 
	role VARCHAR(20), 
	verified BOOLEAN, 
	is_active BOOLEAN, 
	credit_score FLOAT, 
	created_at DATETIME NOT NULL, 
	PRIMARY KEY (id)
)
```

```dataset
CREATE TABLE task (
	id INTEGER NOT NULL, 
	title VARCHAR(120) NOT NULL, 
	description TEXT NOT NULL, 
	reward_amount FLOAT NOT NULL, 
	category VARCHAR(8), 
	urgency VARCHAR(6) NOT NULL, 
	pickup_location_name VARCHAR(120) NOT NULL, 
	pickup_lat FLOAT, 
	pickup_lng FLOAT, 
	dropoff_location_name VARCHAR(120) NOT NULL, 
	dropoff_lat FLOAT, 
	dropoff_lng FLOAT, 
	status VARCHAR(10) NOT NULL, 
	expires_at DATETIME, 
	grab_expires_at DATETIME, 
	cancelled_by VARCHAR(20), 
	created_at DATETIME NOT NULL, 
	updated_at DATETIME NOT NULL, 
	created_by_id INTEGER NOT NULL, 
	assigned_to_id INTEGER, 
	PRIMARY KEY (id), 
	FOREIGN KEY(created_by_id) REFERENCES user (id) ON DELETE CASCADE, 
	FOREIGN KEY(assigned_to_id) REFERENCES user (id) ON DELETE SET NULL
)
```

## 任务模块

### API接口

- `GET /api/tasks`: 获取任务列表（支持筛选和排序）
- `POST /api/tasks`: 发布新任务
- `GET /api/tasks/{task_id}`: 获取任务详情
- `PUT /api/tasks/{task_id}`: 更新任务状态
- `GET /api/tasks/my`: 获取与当前用户相关的所有任务
    - 参数 `role`: `creator` (我发布的) 或 `assignee` (我接单的)，不传则返回全部相关任务
    - 参数 `status`: 状态筛选

## chat模块

### 数据库设计

```dataset
CREATE TABLE message (
	id INTEGER NOT NULL, 
	task_id INTEGER NOT NULL, 
	sender_id INTEGER NOT NULL, 
	receiver_id INTEGER NOT NULL, 
	content TEXT NOT NULL, 
	is_read BOOLEAN DEFAULT FALSE, 
	created_at DATETIME NOT NULL, 
	PRIMARY KEY (id), 
	FOREIGN KEY(task_id) REFERENCES task (id) ON DELETE CASCADE, 
	FOREIGN KEY(sender_id) REFERENCES user (id), 
	FOREIGN KEY(receiver_id) REFERENCES user (id)
)
```

### API接口

- `POST /api/chat/send`: 发送消息
- `GET /api/chat/history/{task_id}`: 获取特定任务的聊天记录
- `GET /api/chat/sessions`: 获取当前用户的所有聊天会话列表

## 评价模块（带打分）

### 数据库设计

```dataset
CREATE TABLE evaluation (
	id INTEGER NOT NULL, 
	task_id INTEGER NOT NULL, 
	evaluator_id INTEGER NOT NULL, 
	evaluatee_id INTEGER NOT NULL, 
	score FLOAT NOT NULL, 
	comment TEXT, 
	created_at DATETIME NOT NULL, 
	PRIMARY KEY (id), 
	FOREIGN KEY(task_id) REFERENCES task (id) ON DELETE CASCADE, 
	FOREIGN KEY(evaluator_id) REFERENCES user (id), 
	FOREIGN KEY(evaluatee_id) REFERENCES user (id)
)
```

### API接口

- `POST /api/evaluation/submit`: 提交评价
- `GET /api/evaluation/user/{user_id}`: 获取指定用户的评价列表及平均分
- `GET /api/evaluation/task/{task_id}`: 获取特定任务的评价信息

## 支付模块（使用余额机制模拟）

### 数据库设计

```dataset
CREATE TABLE wallet (
	user_id INTEGER NOT NULL, 
	balance FLOAT DEFAULT 0.0, 
	updated_at DATETIME NOT NULL, 
	PRIMARY KEY (user_id), 
	FOREIGN KEY(user_id) REFERENCES user (id) ON DELETE CASCADE
)

CREATE TABLE transaction (
	id INTEGER NOT NULL, 
	user_id INTEGER NOT NULL, 
	amount FLOAT NOT NULL, 
	type VARCHAR(20) NOT NULL, -- 'deposit', 'withdraw', 'payment', 'reward'
	related_id INTEGER, -- 关联的任务ID或其他业务ID
	description VARCHAR(255),
	created_at DATETIME NOT NULL, 
	PRIMARY KEY (id), 
	FOREIGN KEY(user_id) REFERENCES user (id)
)
```

### API接口

- `GET /api/payment/balance`: 查询余额
- `POST /api/payment/recharge`: 模拟充值
- `GET /api/payment/transactions`: 获取交易流水
- `POST /api/payment/pay`: 支付任务赏金（冻结/扣除）
- `POST /api/payment/settle`: 结算赏金给接单人

## 申诉模块（发起/处理工单（是否已解决/回复））

### 数据库设计

```dataset
CREATE TABLE appeal (
	id INTEGER NOT NULL, 
	task_id INTEGER NOT NULL, 
	creator_id INTEGER NOT NULL, 
	reason TEXT NOT NULL, 
	status VARCHAR(20) DEFAULT 'pending', -- 'pending', 'processing', 'resolved', 'rejected'
	admin_reply TEXT, 
	created_at DATETIME NOT NULL, 
	updated_at DATETIME NOT NULL, 
	PRIMARY KEY (id), 
	FOREIGN KEY(task_id) REFERENCES task (id), 
	FOREIGN KEY(creator_id) REFERENCES user (id)
)
```

### API接口

- `POST /api/appeal/create`: 发起申诉
- `GET /api/appeal/my`: 获取我的申诉列表
- `GET /api/appeal/{appeal_id}`: 获取申诉详情
- `PUT /api/appeal/{appeal_id}/handle`: (管理员) 处理申诉/回复工单

## 数据库与接口设计审查及优化建议

### 1. 设计审查
- **Chat模块**:
  - `message` 表结构合理，通过 `task_id` 关联任务，适合订单类即时通讯。
  - **建议**: 考虑到消息量可能很大，建议在 `task_id` 和 `created_at` 上建立索引。
  - **冗余检查**: `sender_id` 和 `receiver_id` 虽然可以通过任务关系推导，但显式存储更灵活（例如支持客服介入），不算冗余。

- **评价模块**:
  - 结构清晰。
  - **建议**: 可以在 `user` 表中增加 `rating_count` 和 `total_rating_score` 字段，避免每次获取用户信息都实时计算平均分，改为在评价提交时更新这两个字段。

- **支付模块**:
  - 使用余额机制模拟是可行的。
  - **建议**: `transaction` 表建议增加 `status` 字段 (pending, success, failed)，特别是涉及提现或充值时。
  - **数据类型**: 金额字段目前使用 `FLOAT`，在实际生产环境中建议使用 `DECIMAL` 以避免精度丢失，但作为课程设计 `FLOAT` 足够。

### 2. 实时聊天技术方案 (Python Flask 推荐)

针对 **Python Flask**，最成熟且简单的方案是使用 **Flask-SocketIO** 库。它封装了 WebSocket，并提供自动降级（如果浏览器不支持 WebSocket 会自动切换到轮询），代码实现非常简洁。

#### 1. 安装依赖
```bash
pip install flask-socketio eventlet
```

#### 2. 后端实现 (app.py)
```python
from flask import Flask, request
from flask_socketio import SocketIO, emit, join_room

app = Flask(__name__)
app.config['SECRET_KEY'] = 'secret!'
# cors_allowed_origins="*" 允许跨域，开发阶段很有用
socketio = SocketIO(app, cors_allowed_origins="*")

# 用户进入聊天页面时加入房间（房间号 = task_id）
@socketio.on('join')
def on_join(data):
    room = data['task_id']
    join_room(room)
    # 可选：通知房间内其他人
    # emit('status', {'msg': '有人进入了房间'}, room=room)

# 接收并转发消息
@socketio.on('send_message')
def handle_message(data):
    task_id = data['task_id']
    content = data['content']
    sender_id = data['sender_id']
    
    # TODO: 1. 将消息写入数据库 (message 表)
    # new_msg = Message(task_id=task_id, sender_id=sender_id, content=content...)
    # db.session.add(new_msg)
    # db.session.commit()
    
    # 2. 广播给房间内的所有人（包括发送者自己，或者前端自己处理回显）
    emit('new_message', data, room=task_id)

if __name__ == '__main__':
    # 注意这里使用 socketio.run 而不是 app.run
    socketio.run(app, debug=True, port=5000)
```

#### 3. 前端实现 (JavaScript)
需要引入 `socket.io-client` 库。

```javascript
// 初始化连接
const socket = io('http://localhost:5000');

// 进入任务详情页时，加入房间
const taskId = 101; // 假设当前任务ID
socket.emit('join', { task_id: taskId });

// 发送消息
function sendMessage() {
    const text = document.getElementById('input').value;
    socket.emit('send_message', {
        task_id: taskId,
        sender_id: currentUser.id,
        content: text
    });
}

// 监听接收消息
socket.on('new_message', function(data) {
    console.log('收到新消息:', data);
    // 将 data.content 追加到聊天窗口
});
```
